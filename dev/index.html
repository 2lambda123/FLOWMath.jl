<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FLOWMath.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FLOWMath.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Quadrature-1"><span>Quadrature</span></a></li><li><a class="tocitem" href="#Root-Finding-1"><span>Root Finding</span></a></li><li><a class="tocitem" href="#Interpolation-1"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Smoothing-1"><span>Smoothing</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWMath.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FLOWMath.jl-1"><a class="docs-heading-anchor" href="#FLOWMath.jl-1">FLOWMath.jl</a><a class="docs-heading-anchor-permalink" href="#FLOWMath.jl-1" title="Permalink"></a></h1><p>Examples of the available methods are shown below.  More examples are available in the test suite (/test/runtests.jl)</p><h2 id="Quadrature-1"><a class="docs-heading-anchor" href="#Quadrature-1">Quadrature</a><a class="docs-heading-anchor-permalink" href="#Quadrature-1" title="Permalink"></a></h2><h3 id="Trapezoidal-Integration-1"><a class="docs-heading-anchor" href="#Trapezoidal-Integration-1">Trapezoidal Integration</a><a class="docs-heading-anchor-permalink" href="#Trapezoidal-Integration-1" title="Permalink"></a></h3><p>This is just simple trapezoidal integration using vectors.  <a href="https://github.com/JuliaMath/QuadGK.jl">Gaussian quadrature</a> is much better, but for times when we need to define a mesh for other purposes and cannot use an adaptive method a simple trapezoidal integration fits the bill.</p><pre><code class="language-julia">using FLOWMath: trapz

x = range(0.0, pi+1e-15, step=pi/100)
y = sin.(x)
z = trapz(x, y)</code></pre><pre><code class="language-none">1.9998355038874442</code></pre><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.trapz" href="#FLOWMath.trapz"><code>FLOWMath.trapz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trapz(x, y)</code></pre><p>Integrate y w.r.t. x using the trapezoidal method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/quadrature.jl#LL6-L10">source</a></section></article><h2 id="Root-Finding-1"><a class="docs-heading-anchor" href="#Root-Finding-1">Root Finding</a><a class="docs-heading-anchor-permalink" href="#Root-Finding-1" title="Permalink"></a></h2><h3 id="Brent&#39;s-Method-(1D-functions)-1"><a class="docs-heading-anchor" href="#Brent&#39;s-Method-(1D-functions)-1">Brent&#39;s Method (1D functions)</a><a class="docs-heading-anchor-permalink" href="#Brent&#39;s-Method-(1D-functions)-1" title="Permalink"></a></h3><p>Brent&#39;s method is an effective 1D root finding method as it combines bracketing methods (bisection) with fast quadratic interpolation.  Thus, you can get near quadratic convergence but with safeguarding.</p><pre><code class="language-julia">using FLOWMath: brent

f(x) = x^2 - 1.0
xstar = brent(f, -2.0, 0)</code></pre><pre><code class="language-none">-1.0</code></pre><p>The above example shows basic usage.  Additional inputs and outputs are available as described below.</p><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.brent" href="#FLOWMath.brent"><code>FLOWMath.brent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">brent(f, a, b; args=(), atol=2e-12, rtol=4*eps(), maxiter=100, full_output=false)</code></pre><p>1D root finding using Brent&#39;s method.  Based off the brentq implementation in scipy.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: scalar function, that optionally takes additional arguments</li><li><code>a</code>::Float, b::Float`: bracketing interval for a root - sign changes sign between: (f(a) * f(b) &lt; 0)</li><li><code>args::Tuple</code>: tuple of additional arguments to pass to f</li><li><code>atol::Float</code>: absolute tolerance (positive) for root</li><li><code>rtol::Float</code>: relative tolerance for root</li><li><code>maxiter::Int</code>: maximum number of iterations allowed</li><li><code>full_output::Bool</code>: flag to indicate whether you want just the root, or the root with a    second argument (tuple) containing the number of iterations, function calls, and a convergence message.</li></ul><p><strong>Returns</strong></p><ul><li><code>xstar::Float</code>: a root of f</li><li><code>info::Tuple</code>: returned if <code>full_output=True</code>.  A named tuple containing:<ul><li><code>iter::Int</code>: number of iterations</li><li>&#39;fcalls::Int`: number of function calls</li><li>&#39;flag::String`: a convergence/error message.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/roots.jl#LL6-L27">source</a></section></article><h2 id="Interpolation-1"><a class="docs-heading-anchor" href="#Interpolation-1">Interpolation</a><a class="docs-heading-anchor-permalink" href="#Interpolation-1" title="Permalink"></a></h2><h3 id="Akima-Spline-1"><a class="docs-heading-anchor" href="#Akima-Spline-1">Akima Spline</a><a class="docs-heading-anchor-permalink" href="#Akima-Spline-1" title="Permalink"></a></h3><p>An Akima spline is a 1D spline that avoids overshooting issues common with many other polynomial splines resulting in a more natural curve.  It also only uses local support allowing for more efficient computation.</p><p>Interpolation is perhaps clearest through plotting so we&#39;ll load a plotting package for this examples.</p><pre><code class="language-julia">using PyPlot</code></pre><pre><code class="language-none">[ Info: Installing matplotlib via the Conda matplotlib package...
[ Info: Running `conda install -y matplotlib` in root environment
Collecting package metadata (current_repodata.json): ...working... done
Solving environment: ...working... done

## Package Plan ##

  environment location: /home/runner/.julia/conda/3

  added / updated specs:
    - matplotlib


The following packages will be downloaded:

    package                    |            build
    ---------------------------|-----------------
    cycler-0.10.0              |           py37_0          13 KB
    dbus-1.13.12               |       h746ee38_0         501 KB
    expat-2.2.6                |       he6710b0_0         146 KB
    fontconfig-2.13.0          |       h9420a91_0         227 KB
    freetype-2.9.1             |       h8a8886c_1         550 KB
    glib-2.63.1                |       h5a9c865_0         2.9 MB
    gst-plugins-base-1.14.0    |       hbbd80ab_1         4.8 MB
    gstreamer-1.14.0           |       hb453b48_1         3.1 MB
    icu-58.2                   |       h9c2bf20_1        10.3 MB
    jpeg-9b                    |       h024ee3a_2         214 KB
    kiwisolver-1.1.0           |   py37he6710b0_0          82 KB
    libpng-1.6.37              |       hbc83047_0         278 KB
    libuuid-1.0.3              |       h1bed415_2          15 KB
    libxcb-1.13                |       h1bed415_1         421 KB
    libxml2-2.9.9              |       hea5a465_1         1.6 MB
    matplotlib-3.1.1           |   py37h5429711_0         5.0 MB
    pcre-8.43                  |       he6710b0_0         209 KB
    pyparsing-2.4.6            |             py_0          64 KB
    pyqt-5.9.2                 |   py37h05f1152_2         4.5 MB
    python-dateutil-2.8.1      |             py_0         224 KB
    pytz-2019.3                |             py_0         231 KB
    qt-5.9.7                   |       h5867ecd_1        68.5 MB
    sip-4.19.8                 |   py37hf484d3e_0         274 KB
    tornado-6.0.3              |   py37h7b6447c_0         584 KB
    ------------------------------------------------------------
                                           Total:       104.5 MB

The following NEW packages will be INSTALLED:

  cycler             pkgs/main/linux-64::cycler-0.10.0-py37_0
  dbus               pkgs/main/linux-64::dbus-1.13.12-h746ee38_0
  expat              pkgs/main/linux-64::expat-2.2.6-he6710b0_0
  fontconfig         pkgs/main/linux-64::fontconfig-2.13.0-h9420a91_0
  freetype           pkgs/main/linux-64::freetype-2.9.1-h8a8886c_1
  glib               pkgs/main/linux-64::glib-2.63.1-h5a9c865_0
  gst-plugins-base   pkgs/main/linux-64::gst-plugins-base-1.14.0-hbbd80ab_1
  gstreamer          pkgs/main/linux-64::gstreamer-1.14.0-hb453b48_1
  icu                pkgs/main/linux-64::icu-58.2-h9c2bf20_1
  jpeg               pkgs/main/linux-64::jpeg-9b-h024ee3a_2
  kiwisolver         pkgs/main/linux-64::kiwisolver-1.1.0-py37he6710b0_0
  libpng             pkgs/main/linux-64::libpng-1.6.37-hbc83047_0
  libuuid            pkgs/main/linux-64::libuuid-1.0.3-h1bed415_2
  libxcb             pkgs/main/linux-64::libxcb-1.13-h1bed415_1
  libxml2            pkgs/main/linux-64::libxml2-2.9.9-hea5a465_1
  matplotlib         pkgs/main/linux-64::matplotlib-3.1.1-py37h5429711_0
  pcre               pkgs/main/linux-64::pcre-8.43-he6710b0_0
  pyparsing          pkgs/main/noarch::pyparsing-2.4.6-py_0
  pyqt               pkgs/main/linux-64::pyqt-5.9.2-py37h05f1152_2
  python-dateutil    pkgs/main/noarch::python-dateutil-2.8.1-py_0
  pytz               pkgs/main/noarch::pytz-2019.3-py_0
  qt                 pkgs/main/linux-64::qt-5.9.7-h5867ecd_1
  sip                pkgs/main/linux-64::sip-4.19.8-py37hf484d3e_0
  tornado            pkgs/main/linux-64::tornado-6.0.3-py37h7b6447c_0



Downloading and Extracting Packages
expat-2.2.6          | 146 KB    |            |   0% expat-2.2.6          | 146 KB    | ########## | 100%
libxml2-2.9.9        | 1.6 MB    |            |   0% libxml2-2.9.9        | 1.6 MB    | ########## | 100%
dbus-1.13.12         | 501 KB    |            |   0% dbus-1.13.12         | 501 KB    | ########## | 100%
icu-58.2             | 10.3 MB   |            |   0% icu-58.2             | 10.3 MB   | ########## | 100%
qt-5.9.7             | 68.5 MB   |            |   0% qt-5.9.7             | 68.5 MB   | #1         |  12% qt-5.9.7             | 68.5 MB   | ###        |  31% qt-5.9.7             | 68.5 MB   | #####1     |  51% qt-5.9.7             | 68.5 MB   | #######2   |  72% qt-5.9.7             | 68.5 MB   | #########3 |  94% qt-5.9.7             | 68.5 MB   | ########## | 100%
kiwisolver-1.1.0     | 82 KB     |            |   0% kiwisolver-1.1.0     | 82 KB     | ########## | 100%
pcre-8.43            | 209 KB    |            |   0% pcre-8.43            | 209 KB    | ########## | 100%
freetype-2.9.1       | 550 KB    |            |   0% freetype-2.9.1       | 550 KB    | ########## | 100%
fontconfig-2.13.0    | 227 KB    |            |   0% fontconfig-2.13.0    | 227 KB    | ########## | 100%
pyqt-5.9.2           | 4.5 MB    |            |   0% pyqt-5.9.2           | 4.5 MB    | ########## | 100%
libxcb-1.13          | 421 KB    |            |   0% libxcb-1.13          | 421 KB    | ########## | 100%
libpng-1.6.37        | 278 KB    |            |   0% libpng-1.6.37        | 278 KB    | ########## | 100%
sip-4.19.8           | 274 KB    |            |   0% sip-4.19.8           | 274 KB    | ########## | 100%
tornado-6.0.3        | 584 KB    |            |   0% tornado-6.0.3        | 584 KB    | ########## | 100%
gst-plugins-base-1.1 | 4.8 MB    |            |   0% gst-plugins-base-1.1 | 4.8 MB    | ########## | 100%
glib-2.63.1          | 2.9 MB    |            |   0% glib-2.63.1          | 2.9 MB    | ########## | 100%
jpeg-9b              | 214 KB    |            |   0% jpeg-9b              | 214 KB    | ########## | 100%
python-dateutil-2.8. | 224 KB    |            |   0% python-dateutil-2.8. | 224 KB    | ########## | 100%
cycler-0.10.0        | 13 KB     |            |   0% cycler-0.10.0        | 13 KB     | ########## | 100%
libuuid-1.0.3        | 15 KB     |            |   0% libuuid-1.0.3        | 15 KB     | ########## | 100%
matplotlib-3.1.1     | 5.0 MB    |            |   0% matplotlib-3.1.1     | 5.0 MB    | ########## | 100%
pytz-2019.3          | 231 KB    |            |   0% pytz-2019.3          | 231 KB    | ########## | 100%
gstreamer-1.14.0     | 3.1 MB    |            |   0% gstreamer-1.14.0     | 3.1 MB    | ########## | 100%
pyparsing-2.4.6      | 64 KB     |            |   0% pyparsing-2.4.6      | 64 KB     | ########## | 100%
Preparing transaction: ...working... done
Verifying transaction: ...working... done
Executing transaction: ...working... done</code></pre><pre><code class="language-julia">using FLOWMath: akima, Akima

x = 0:pi/4:2*pi
y = sin.(x)
xpt = 0:pi/16:2*pi

ypt = akima(x, y, xpt)

figure()
plot(x, y, &quot;o&quot;)
plot(xpt, ypt)</code></pre><p><img src="interp.svg" alt/></p><p>or if you plan to evaluate the spline repeatedly</p><pre><code class="language-julia">spline = Akima(x, y)
ypt = similar(xpt)
ypt .= spline.(xpt) # ypt change in place
ypt = spline(xpt)</code></pre><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.Akima" href="#FLOWMath.Akima"><code>FLOWMath.Akima</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Akima(xdata, ydata, delta_x=0.0)</code></pre><p>Creates an akima spline at node points: <code>xdata</code>, <code>ydata</code>.  This is a 1D spline that avoids overshooting issues common with many other polynomial splines resulting in a more natural curve.  It also only depends on local points (<code>i-2</code>...<code>i+2</code>) allow for more efficient computation.  <code>delta_x</code> is the half width of a smoothing interval used for the absolute value function.  Set <code>delta_x=0</code> to recover the original akima spline.  The smoothing is only useful if you want to differentiate xdata and ydata.  In many case the nodal points are fixed so this is not needed.  Returns an akima spline object (Akima struct). This function, only performs construction of the spline, not evaluation. This is useful if you want to evaluate the same mesh at multiple different conditions. A convenience method exists below to perform both in one shot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/interpolate.jl#LL23-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.akima" href="#FLOWMath.akima"><code>FLOWMath.akima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">akima(x, y, xpt)</code></pre><p>A convenience method to perform construction and evaluation of the spline in one step. See docstring for Akima for more details.  </p><p><strong>Arguments</strong></p><ul><li><code>x, y::Vector{Float}</code>: the node points</li><li><code>xpt::Vector{Float} or ::Float</code>: the evaluation point(s)</li></ul><p><strong>Returns</strong></p><ul><li><code>ypt::Vector{Float} or ::Float</code>: interpolated value(s) at xpt using akima spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/interpolate.jl#LL105-L117">source</a></section></article><h3 id="D/3D/4D-Interpolation-using-Recursive-1D-Interpolation-1"><a class="docs-heading-anchor" href="#D/3D/4D-Interpolation-using-Recursive-1D-Interpolation-1">2D/3D/4D Interpolation using Recursive 1D Interpolation</a><a class="docs-heading-anchor-permalink" href="#D/3D/4D-Interpolation-using-Recursive-1D-Interpolation-1" title="Permalink"></a></h3><p>The functions <code>interp2d</code>, <code>interp3d</code>, and <code>interp4d</code> are generic and will accept any method that performs 1D interpolation as the first argument.  In the below examples, akima is used.  These examples are based off of examples from Matlab&#39;s interpn documentation.</p><p>2D:</p><pre><code class="language-julia">using FLOWMath: interp2d

x = -5.0:5.0
y = -5.0:5.0
z = zeros(11, 11)
for i = 1:11
    for j = 1:11
        v = sqrt(x[i]^2 + y[j]^2) + 1e-15
        z[i, j] = sin(v) / v
    end
end

xpt = range(-5.0, 5.0, length=100)
ypt = range(-5.0, 5.0, length=100)

zpt = interp2d(akima, x, y, z, xpt, ypt)

figure()
contour(xpt, ypt, zpt)</code></pre><p><img src="contour.svg" alt/></p><p>4D:</p><pre><code class="language-julia">using FLOWMath: interp4d

x = -1:0.2:1
y = -1:0.2:1
z = -1:0.2:1
t = 0:2:10.0

nx = length(x)
ny = length(y)
nz = length(z)
nt = length(t)

f = Array{typeof(x[1])}(undef, nx, ny, nz, nt)

for i = 1:nx
    for j = 1:ny
        for k = 1:nz
            for l = 1:nt
                f[i, j, k, l] = t[l]*exp(-x[i]^2 - y[j]^2 - z[k]^2)
            end
        end
    end
end

xpt = -1:0.05:1
ypt = -1:0.08:1
zpt = -1:0.05:1
tpt = 0:0.5:10.0

fpt = interp4d(akima, x, y, z, t, f, xpt, ypt, zpt, tpt)</code></pre><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.interp2d" href="#FLOWMath.interp2d"><code>FLOWMath.interp2d</code></a> — <span class="docstring-category">Function</span></header><section><div><p>interp2d(interp1d, xdata, ydata, fdata, xpt, ypt)</p><p>2D interpolation using recursive 1D interpolation.  This approach is likely less efficient than a more direct 2D interpolation method, especially one you can create separate creation from evaluation, but it is generalizable to any spline approach and any dimension.</p><p><strong>Arguments</strong></p><ul><li><code>interp1d</code>: any spline function of form: ypt = interp1d(xdata, ydata, xpt) where data are the known   data(node) points and pt are the points where you want to evaluate the spline at.</li><li><code>xdata::Vector{Float}</code>, <code>ydata::Vector{Float}</code>: Define the 2D grid</li><li><code>fdata::Matrix{Float}</code>: where fdata[i, j] is the function value at xdata[i], ydata[j]</li><li><code>xpt::Vector{Float}</code>, <code>ypt::Vector{Float}</code>: the locations where you want to evaluate the spline</li></ul><p><strong>Returns</strong></p><ul><li><code>fhat::Matrix{Float}</code>: where fhat[i, j] is the estimate function value at xpt[i], ypt[j]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/interpolate.jl#LL122-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.interp3d" href="#FLOWMath.interp3d"><code>FLOWMath.interp3d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interp3d(interp1d, xdata, ydata, zdata, fdata, xpt, ypt, zpt)</code></pre><p>Same as interp2d, except in three dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/interpolate.jl#LL158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.interp4d" href="#FLOWMath.interp4d"><code>FLOWMath.interp4d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interp4d(interp1d, xdata, ydata, zdata, fdata, xpt, ypt, zpt)</code></pre><p>Same as interp3d, except in four dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/interpolate.jl#LL185-L189">source</a></section></article><h2 id="Smoothing-1"><a class="docs-heading-anchor" href="#Smoothing-1">Smoothing</a><a class="docs-heading-anchor-permalink" href="#Smoothing-1" title="Permalink"></a></h2><h3 id="Absolute-value-1"><a class="docs-heading-anchor" href="#Absolute-value-1">Absolute value</a><a class="docs-heading-anchor-permalink" href="#Absolute-value-1" title="Permalink"></a></h3><p>The absolute value function is not differentiable at x = 0.  The below function smoothly adds a small quadratic function in place of the cusp with a half-width given by <code>delta_x</code>.  This small rounding at the bottom can prevent numerical issues with gradient-based optimization.</p><pre><code class="language-julia">using FLOWMath: abs_smooth

x = range(-2.0, 2.0, length=100)
delta_x = 0.1

y = abs_smooth.(x, delta_x)

using PyPlot
figure()
plot(x, y)</code></pre><p><img src="abs.svg" alt/></p><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.abs_smooth" href="#FLOWMath.abs_smooth"><code>FLOWMath.abs_smooth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abs_smooth(x, delta_x)</code></pre><p>Smooth out the absolute value function with a quadratic interval. delta_x is the half width of the smoothing interval. Typically usage is with gradient-based optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/smooth.jl#LL4-L10">source</a></section></article><h3 id="Kreisselmeier-Steinhauser-Constraint-Aggregation-Function-1"><a class="docs-heading-anchor" href="#Kreisselmeier-Steinhauser-Constraint-Aggregation-Function-1">Kreisselmeier-Steinhauser Constraint Aggregation Function</a><a class="docs-heading-anchor-permalink" href="#Kreisselmeier-Steinhauser-Constraint-Aggregation-Function-1" title="Permalink"></a></h3><p>The Kreisselmeier-Steinhauser (KS) function is often used with constrained gradient-based optimization problems to smoothly aggregate an arbitrary number of constraints into a single constraint.  It may also be used as a smooth approximation of the maximum function (or minimum function).  A salient feature of this function is that it is guaranteed to overestimate the maximum function (or underestimate the minimum function).  This feature of the function can be used to ensure that the resulting constraint is conservative.  </p><p>We provide two implementations of this function: <code>ksmax</code> and <code>ksmin</code>.  <code>ksmax</code> and <code>ksmin</code> may be used to smoothly approximate the maximum and minimum functions, respectively.  Both functions take the optional parameter <code>hardness</code> that controls the smoothness of the resulting function.  As <code>hardness</code> increases the function more and more closely approximates the maximum (or minimum) function.</p><pre><code class="language-julia">using FLOWMath: ksmax, ksmin

x = [1.2, 0.0, 0.5]
hardness = 100
max_x = ksmax(x, hardness)</code></pre><pre><code class="language-none">1.2</code></pre><pre><code class="language-julia">min_x = ksmin(x, hardness)</code></pre><pre><code class="language-none">-0.0</code></pre><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.ksmax" href="#FLOWMath.ksmax"><code>FLOWMath.ksmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ksmax(x, hardness=50)</code></pre><p>Kreisselmeier–Steinhauser constraint aggregation function.  In the limit as <code>hardness</code> goes to infinity the maximum function is returned. Is mathematically guaranteed to overestimate the maximum function, i.e. <code>maximum(x) &lt;= ksmax(x, hardness)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/smooth.jl#LL21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.ksmin" href="#FLOWMath.ksmin"><code>FLOWMath.ksmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ksmin(x, hardness=50)</code></pre><p>Kreisselmeier–Steinhauser constraint aggregation function.  In the limit as <code>hardness</code> goes to infinity the minimum function is returned. Is mathematically guaranteed to underestimate the minimum function, i.e. <code>minimum(x) &lt;= ksmin(x, hardness)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/smooth.jl#LL33-L39">source</a></section></article><h3 id="Blending-functions-using-the-sigmoid-function-1"><a class="docs-heading-anchor" href="#Blending-functions-using-the-sigmoid-function-1">Blending functions using the sigmoid function</a><a class="docs-heading-anchor-permalink" href="#Blending-functions-using-the-sigmoid-function-1" title="Permalink"></a></h3><p>The sigmoid function may be used to smoothly blend the results of two continuous one-dimensional functions.  The method implemented in this package uses a user-specified transition location (<code>xt</code>) and scales the input of the sigmoid function using the input <code>hardness</code> in order to adjust the smoothness of the transition between the two functions.</p><pre><code class="language-julia">using FLOWMath: sigmoid_blend

x = 0.1
f1x = x
f2x = x^2
xt = 0.0
hardness = 100
y = sigmoid_blend(f1x, f2x, x, xt, hardness)</code></pre><pre><code class="language-none">0.010004085808183225</code></pre><p><code>sigmoid_blend</code> can also be used with vector inputs using broadcasting.</p><pre><code class="language-julia">x = -0.25:0.01:0.25
f1x = x
f2x = x.^2
xt = 0.0
hardness = 100
y = sigmoid_blend.(f1x, f2x, x, xt, hardness)

using PyPlot
figure()
plot(x, y)</code></pre><p><img src="sigmoid.svg" alt/></p><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.sigmoid_blend" href="#FLOWMath.sigmoid_blend"><code>FLOWMath.sigmoid_blend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigmoid_blend(f1x, f2x, x, xt, hardness=50)</code></pre><p>Smoothly transitions the results of functions f1 and f2 using the sigmoid function, with the transition between the functions located at <code>xt</code>. <code>hardness</code> controls the sharpness of the transition between the two functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/smooth.jl#LL128-L134">source</a></section></article><h3 id="Blending-functions-using-cubic-or-quintic-polynomials-1"><a class="docs-heading-anchor" href="#Blending-functions-using-cubic-or-quintic-polynomials-1">Blending functions using cubic or quintic polynomials</a><a class="docs-heading-anchor-permalink" href="#Blending-functions-using-cubic-or-quintic-polynomials-1" title="Permalink"></a></h3><p>Cubic or quintic polynomials can also be used to construct a piecewise function that smoothly blends two functions.  The advantage of this approach compared to <code>sigmoid_blend</code> is that the blending can be restricted to a small interval defined by the half-width <code>delta_x</code>.  The disadvantage of this approach is that the resulting function is only C1 continuous when <code>cubic_blend</code> is used, and C2 continuous when <code>quintic_blend</code> is used.  The method implemented in this package uses a user-specified transition location (<code>xt</code>).  The smoothness of the transition between the two functions can be adjusted by modifying <code>delta_x</code>, which is the half-width of the transition interval.</p><pre><code class="language-julia">using FLOWMath: cubic_blend, quintic_blend

x = 0.05
f1x = x
f2x = x^2
xt = 0.0
delta_x = 0.1
y1 = cubic_blend(f1x, f2x, x, xt, delta_x)
y2 = quintic_blend(f1x, f2x, x, xt, delta_x)</code></pre><pre><code class="language-none">0.007416992187499999</code></pre><p><code>cubic_blend</code> and <code>quintic_blend</code> can also be used with vector inputs using broadcasting.</p><pre><code class="language-julia">x = -0.25:0.01:0.25
f1x = x
f2x = x.^2
xt = 0.0
delta_x = 0.1
y1 = cubic_blend.(f1x, f2x, x, xt, delta_x)
y2 = quintic_blend.(f1x, f2x, x, xt, delta_x)

using PyPlot
figure()
plot(x, y1)
plot(x, y2)
legend([&quot;cubic&quot;, &quot;quintic&quot;])</code></pre><p><img src="cubic.svg" alt/></p><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.cubic_blend" href="#FLOWMath.cubic_blend"><code>FLOWMath.cubic_blend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cubic_blend(f1x, f2x, x, xt, delta_x)</code></pre><p>Smoothly transitions the results of functions f1 and f2 using a cubic polynomial, with the transition between the functions located at <code>xt</code>. delta_x is the half width of the smoothing interval.  The resulting function is C1 continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/smooth.jl#LL140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWMath.quintic_blend" href="#FLOWMath.quintic_blend"><code>FLOWMath.quintic_blend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quintic_blend(f1x, f2x, x, xt, delta_x)</code></pre><p>Smoothly transitions the results of functions f1 and f2 using a quintic polynomial, with the transition between the functions located at <code>xt</code>. delta_x is the half width of the smoothing interval.  The resulting function is C2 continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/4e1db0ab326b83f23dbbb42c4ae68cfcb71a0198/src/smooth.jl#LL159-L165">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 January 2020 23:10">Thursday 30 January 2020</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
